# Carrera_Python
Proyecto fin de curso Carrera de Desarrollo y tester en Python de OpenWebinars

## Día 1 (18/03/2024): 
### Sesión 1 (16:41)
Curso:  Python 3 desde cero
#### Contenidos vistos:

- Introducción al curso

- Introducción a la programación: Explicación muy básica de la programación, ya visto.

- Introducción a Python 3
- Instalación de Python 3 en Windows
 
- Estructura del programa
Usaré VSCode para programar en Python

 ![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/f159d5f2-9dc1-4474-a871-d9f2afd81378)



- Mi primer programa en Python 3

 ![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/a2a2f0b3-4592-4135-beff-22bdd4825c52)



- Tipos de datos básicos

Datos y tipos de datos: esta parte es muy similar a lo conocido de java pero tiene un par de cambios en ciertas operaciones o funciones, además de la explicación de que python sea un lenguaje no tipado, con lo cual se puede cambiar el tipo de los valores de las variables.

Datos numéricos: algo que cabe destacar es que lo que vienen siendo los parse de java o c# en python se realizan de forma mucho más directa

 ![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/671fdd88-83d0-47e9-b165-0834e00b418e)



Datos booleanos

Trabajando con variables: Se pueden eliminar variables creadas(del nombreVariable). No existe el operador ++, o --, pero si +=,-=...

Entrada y salida de estándar

![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/5f8b86ba-4cba-44bf-a239-3411640d36de)



printf de java funciona de forma similar a java:

print("El producto %s cantidad=%d precio=%.2f"%("cesta",23,13.456))

Las variables van entre paréntesis tras el %.

Introducción a cadenas de caracteres

###Final sesión 1 (18:22)

### Final día 1

## Día 2 (19/03/2024): 

### Sesión 1 (14:55)

Curso: Python 3 desde cero

### Contenidos vistos:

- Tipos de datos básicos
  
De pseudocódigo a Python 3

Ejercicios de estructura secuencial: Ejercicio 3

![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/159a31d5-628f-4f9b-a694-ac2e9df9d7ee)

 
Ahora son 20 ejercicios, los haré todos, estarán en el repositorio, solo pondré imagenes de lo que sea necesario destacar

Hice hasta el ejercicio 12. No hubo dudas grandes ni fallos, unicamente si existen ciertas funciones de math, o cómo son ciertos operadores en python. Los ejercicios son fáciles.

### Fin de la Sesión 1 (16:21)

### Final día 2

## Día 3 (20/03/2024): 

Curso: Python 3 desde cero

### Sesión 1 (00:35)

### Contenidos vistos:

Terminé los ejercicio 12 a 20. Nada que destacar

Los videos que quedan son correcciones guiadas de algunos ejercicios

- Ejercicios de estructura secuencial: Ejercicio X

- Ejercicios de estructura secuencial: Ejercicio XV

- Ejercicios de estructura secuencial: Ejercicio XVII

- Ejercicios de estructura secuencial: Ejercicio XVIII

### Final de la Sesión 1 (02:28)

### Final día 3

## Día 4 (22/03/2024): 

### Sesión 1 (18:26)

Curso: Python 3 desde cero

#### Contenidos vistos:

- Estructuras de control alternativas: Lo único que cabe destacar es que parece que en python no hay switch
Los siguientes puntos vuelven a ser 20 ejercicios de estructuras de control alternativas, que haré y estarán en el repositorio
Acabo de darme cuenta de que python no tiene el tipo de dato "char".
Es curioso como funciona una cosa y no la mencionaron por ahora en el curso; en el ejercicio 6 tenía que comprobar si un caracter está en mayúscula o  en minúscula, para ello hice:

 ![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/60850f0a-1607-492f-8ec4-55086871eeaa)

según cha.isupper, devuelve true o false dependiendo del case de la letra o letras, sin embargo devolvía siempre true. Tuve que ver la solución proporcionada, aunque variaba en la forma de resolver el ejercicio, vi que usaban "cha.upper()" con los paréntesis, y eso me dio a probar cha.isupeer() y eso ya sí que funcionó. Por alguna razón se pueden meter las funciones o métodos de los objetos sin los paréntesis (de hecho vscode autocompleta sin paréntesis) y el código no da error y tira para adelante... No estoy seguro de como funciona, porque al final del día sin los paréntesis estaba devolviendo true de todas formas.

Hice del ejercicio 1 al 7.

- Estructuras de control alternativas: Ejercicio II

- Estructuras de control alternativas: Ejercicio V

### Fin de la Sesión 1 (19:36)

### Sesión 2 (20:30)

Curso: Python 3 desde cero

#### Contenidos vistos:

- Estructuras de control alternativas: Ejercicio IX

Hice del ejercicio 8 al 11

### Fin de la Sesión 2 (21:25)

### Final día 4

## Día 5 (30/03/2024): 

### Sesión 1 (23:50)

Curso:  Python 3 desde cero

#### Contenidos vistos:

Terminados ejercicios del 12 al 20

- Estructuras de control alternativas: Ejercicio IX

- Estructuras de control alternativas: Ejercicio XIII

En el ejercicio 17 me doy cuenta por primera vez que declarar una booleana es distino a otros lenguajes, dado que para decir si algo es true o false dinstintas opciones como "0" o "" darán false, pero para declararlo sin más hay que usar var= bool(False) con False o True la primera en mayúscula.

- Estructuras de control repetitivas: While

 ![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/5de43111-7434-4c11-9e0e-4b79483198a5)

- Estructuras de control repetitivas: For
El for es bastante distinto...

![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/8e6d5ae0-709d-4dff-bce0-edb89674f6d7)

- Uso específico de variables: Contadores, acumuladores e indicadores
Esta parte es lógica de programación básica.

### Fin de la Sesión 1 (01:04)

### Final día 5 

## Día 6 (08/04/2024): 

### Sesión 1 (12:40)

Curso:  Python 3 desde cero

#### Contenidos vistos:

Empiezo con los ejercicios de estructuras repetitivas.

Dado que no me sobra el tiempo, a partir de ahora haré solo parte de los ejercicios.

- Uso de estructuras repetitivas: Ejercicio I

- Uso de estructuras repetitivas: Ejercicio III

### Fin de la Sesión 1 (13:10)

### Final día 6 

## Día 7 (09/04/2024): 

### Sesión 1 (15:00)

Curso:  Python 3 desde cero

#### Contenidos vistos:

Haciendo ejercicios de estructuras repetitivas 3,5,7,10

### Fin de la Sesión 1 (17:16)

### Final día 7 

## Día 8 (12/04/2024): 

### Sesión 1 (8:10)

Curso:  Python 3 desde cero

#### Contenidos vistos:

He de decir, que en la empresa que estoy haciendo las prácticas, trabajo con python. Ya estoy desarrollando código, pero creo que no lo voy a publicar por aquí, por si acaso va en contra del contrato de confidencialidad. Pero puedo decir que tengo que hacer un proyecto de 0 en python y que por ahora ya me vi obligado a buscar información y hacer scripts de:
 - creación de funciones (def funcion():)
 - haciendo uso de multihilo (en proceso)
 - como se escribe y lee un archivo
 - obtención de datos del ordenador
 - creación y control de excepciones
 - capturar el tráfico de red con pyShark (en proceso)
 - creación y control de una base de datos con powerBi (en proceso)
 - programar de forma orientada a objetos. (en proceso)
 - creación de archivos ejecutables .exe (con pyinstaller y autopy2exe)

 Mis fuentes por ahora fueron StackOverflow, W3Cschools, documentación de Python, Medium.com...

La verdad es que python, quitando un par de cosas, es muy fácil de entender y usar, sobretodo con experiencia en programación. Cosas como escribir en archivos es tan sencillo como poner "open( )", y luego un parámetro para escoger lo que hacer con el archivo. No tiene ninguna complicación. Mi objetivo ahora es alcanzar lo antes posible los cursos que tengan información relevante a las partes que tengo en proceso ahora mismo para hacerlas de forma adecuada, por lo tanto reduciré el número de ejercicios opcionales y me pararé menos a comentar detalles.

Apartados del curso vistos:

- Tipos de datos secuenciales

-- Cadenas de caracteres

-- Las cadenas de caracteres son inmutables

-- Métodos principales de cadenas

-- Ejercicios de cadenas de caracteres: Ejericicio 2

-- Ejercicios de cadenas de caracteres: Ejericicio 3

-- Ejercicios de cadenas de caracteres: Ejericicio 4

-- Ejercicios de cadenas de caracteres: Ejericicio 9

-- Listas

-- Las listas son mutables

-- Métodos de las listas

-- Tuplas

-- Ejercicios de listas: Ejericicio 1

-- Ejercicios de listas: Ejericicio 3

-- Ejercicios de listas: Ejericicio 8

-- Ejercicios de listas: Ejericicio 10

- Tipos de datos mapas

-- Diccionario

-- Métodos principales de diccionarios

-- Ejercicios de diccionarios: Ejericicio 2

-- Ejercicios de diccionarios: Ejericicio 3

- Excepciones

-- Excepciones

```python 
 try:
   print (10/int(cad))
 except ValueError:
   print("No se puede convertir a entero")
 except ZeroDivisionError:
   print("No se puede dividir por cero")
 else:
   print("Otro error")
```

- Introducción a los módulos

-- Introducción a los módulos

- Programación estructurada

-- Introducción a las funciones

-- Funciones recursivas

-- Ejercicios con funciones: Ejericicio 2

-- Ejercicios con funciones: Ejericicio 5

-- Ejercicios con funciones: Ejericicio 11

### Fin de la Sesión 1 (14:20)

### Sesión 2 (15:14)

Curso:  Python 3 desde cero

#### Contenidos vistos:

- Programación orientada a objetos

-- Introducción a la programación orientada a objetos

Esta parte es un poco rara; se empieza poniendo class nombre_clase(), this viene siendo self, y el constructor es una función __init__():

```python
import math
class punto():
""" Representación de un punto en el plano, los atributos son x e y
que representan los valores de las coordenadas cartesianas."""

def __init__(self,x=0,y=0):
    self.x=x
    self.y=y

def mostrar(self):
    return str(self.x)+":"+str(self.y)

def distancia(self, otro):
    """ Devuelve la distancia entre ambos puntos. """
    dx = self.x - otro.x
    dy = self.y - otro.y
    return math.sqrt((dx*dx + dy*dy))
```

-- Encapsulamiento en la programación orientada a objetos

A la hora de crear objetos, las propiedades privados se establecen como _propiedad y para definir setters y getter:

```python

class circulo():

def __init__(self,radio):
    self.radio=radio

#getter
@property
def radio(self):
    return self._radio

#setter
@radio.setter
def radio(self,radio)
    if radio>=0:
        self._radio=radio
    else:
        print("Radio debe ser positivo")
        self._radio=0
```

### Fin de la Sesión 2 (16:20)

### Final día 8 

## Bonus (13/04/2024)

Hoy estaba jugando a Jump King, un videojuego de plataformas que se basa en hacer una serie de saltos precisos para alcanzar a una princesa en lo alto de una torre. El principal punto de este juego es el hecho de que no hay checkpoints, todo el progreso (y su pérdida) se guarda. Está diseñado para ser difícil y frustrante. Pues resulta que se le puede hacer savescum, un proceso por el cual puedes modificar el archivo de guardado (de la ultima posición del personaje). El proceso viene siendo hacer una copia del archivo de guardado "combined.sav" en un punto que quieras repetir, y cuando pierdas progreso, simplemente sustituyes el save original por la copia (se debe cerrar el juego previamente).

No suelo hacer trampas en este tipo de juegos, porque pierde el propósito del reto, sin embargo, pensé que sería muy fácil hacer un script en python, así que lo hice para probarme. Así también queda por aquí.

El resultado está en la carpeta "autoSaveScum", y tiene un script muy básico (autoSave.py):
```python
import shutil, psutil, os
from pathlib import Path

#Busca y termina el proceso del juego, por su nombre
for proc in psutil.process_iter():
    if proc.name() == "JumpKing.exe":
        print("Cerrando JumpKing")
        proc.kill()

try:
    #Cambia los archivos

    print("Cambiando partida guardada")
    shutil.copyfile(str(Path.home())+"\\Desktop\\Nueva carpeta\\combined.sav","C:\\GOG Games\\Jump King\\Content\\Saves\\combined.sav")
    
    try:
        #Ejecuta el juego
        
        print("Ejecutando JumpKing")
        os.chdir("C:\\GOG Games\\Jump King")
        os.startfile("C:\\GOG Games\\Jump King\\JumpKing.exe")
    except:
        print("Error al ejecutar JumpKing")
        
except IOError as e:
    print("Error al copiar:",e)

```

También, cree un archivo ejecutable .exe, poniendome en el directorio del script desde una consola de comandos y ejecutando el comando "pyinstaller autoSave.exe", lo que genera las carpetas "dist" y "build". En dist se encuentra el ejecutable

## Día 9 (15/04/2024): 

### Sesión 1 (7:50)

Curso:  Python 3 desde cero

#### Contenidos vistos:

- Herencia y delegación

- Ejercicios de programación orientada a objetos

- Hice el examen, ya está aprobado

Curso: Python 3

Este nuevo curso contiene contenidos muy similares al anterior, ya que es la introducción más conceptos avanzados, así que me limitaré a comentar el contenido nuevo:

Se podría hacer una alternativa de la siguiente forma:

```python
saludo="hola" if lang=="es" else "hi"
```
- Tipos de datos binarios: bytes, bytearray

- Tipos de datos conjuntos: set, frozenset:

```python
set={[1,1,1,2,3,3,3]}
#devuelve: {1,2,3}
#set es mutable, frozenset es inmutable
```

- Tipos de datos: iterador y generador

### Fin de la Sesión 1 (10:10)

### Final día 9

## Bonus (15/04/2024)
Hoy en las prácticas seguí investigando como capturar el tráfico de red. Encontré una forma usando Scapy. Paso el test que hice para probarlo:

```python
from scapy.all import *

def sniffPackets(packet):
    if "IP" in packet:
        time= packet.time
        src= packet["IP"].src
        dst= packet["IP"].dst
        protoNum = packet["IP"].proto
        
        if protoNum==6:
            proto= "TCP"
        elif protoNum==17:
            proto= "UDP"

        length= len(packet)
        info= packet.summary()
    elif "Ether" in packet:
        time= packet.time
        src= packet["Ether"].src
        dst= packet["Ether"].dst
        proto = packet["Ether"].type
        length= len(packet)
        info= packet.summary()
        
    print("Time:",time,"Source:",src,"Destination:",dst,"Protocol:",proto,"Length:",length,"Info:",info)

sniff(prn=sniffPackets, count=3)
```

Devuelve:

![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/bccd3e65-26aa-4f65-abb7-01a6f99dd3c8)

También hice una prueba para ver como funcionaba el threading:

```python
import threading
import time

# Variable compartida
shared_variable = 0

# Función para incrementar la variable
def incrementar():
    global shared_variable
    while shared_variable < 100:
        shared_variable += 1
        print(f"Hilo 1: {shared_variable}")

# Crear un segundo hilo para decrementar la variable
def decrementar():
    global shared_variable
    while shared_variable > -100:
        shared_variable -= 1
        print(f"Hilo 2: {shared_variable}")

# Crear los hilos
mi_hilo1 = threading.Thread(target=incrementar)
mi_hilo2 = threading.Thread(target=decrementar)

# Iniciar los hilos
mi_hilo1.start()
mi_hilo2.start()

# Esperar a que ambos hilos terminen
mi_hilo1.join()
mi_hilo2.join()

print("Ambos hilos han terminado")

```

## Día 10 (17/04/2024): 

### Sesión 1 (8:00)

Curso:  Python 3

#### Contenidos vistos:

- Trabajar con ficheros

-- Lectura y escritura de ficheros:

```python
#w=overwrite, r=read, a=append, w+=write+read, a+=append+read...
f=open("lecturaEscrituraFicheros/ejemplo1.txt","w")
f.write("Hey hey o/")
f.close()

#en una linea:
with open("lecturaEscrituraFicheros/ejemplo1.txt","r") as archivo:
    contenido=archivo.read()
print(contenido)
```

-- Gestionar ficheros CSV:

```python
import csv
fichero=open("lecturaEscrituraFicheros/ejemplo2.csv","r")

#Para evitar conflicto con las comillas de los datos
contenido=csv.reader(fichero,quotechar='"')

for row in contenido:
    print(row)

#Devuelve:
""" 
['AÃ±o', 'Marca', 'Modelo', 'DescripciÃ³n', 'Precio']
['1997', 'Ford', 'E350', 'ac, abs, moon', '3000.00']
['1999', 'Chevy', 'Venture "Extended Edition"', '', '4900.00']
['1999', 'Chevy', 'Venture "Extended Edition, Very Large"', '', '5000.00']
['1996', 'Jeep', 'Grand Cherokee', 'MUST SELL!]
[air, moon roof, loaded', '4799.00'] """
```

Esto mola, porque con csv se trabaja en powerBI, un servio de análisis de datos de microsoft que usan muchas empresas, yo tendré que usarlo seguramente durante las prácticas, y por ahora ya hice unos scripts que recogían información y la pasaban a csv, para más adelante analizarla y compararla.

Mini Bonus:
por ejemplo, uno de los scripts almacena la informacion del comando "wmic qfe list" en formato csv, la cual luego se puede organizar muy facilmente en tablas en excel

![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/14791c44-3c36-4d9d-b2df-7eca96ab5613)


-- Gestión de ficheros json

### Final sesión 1 (11:12)

## Día 11 (21/04/2024): 

### Sesión 1 (20:00)

Curso:  Python 3

#### Contenidos vistos:

- Programación estructurada y modular

- Programación orientada a objetos

Ya hice el examen, está aprobado

### Final sesión 1 (13:34)

## Bonus (23/04/2024)

Hoy empecé a trastear con power BI en las prácticas, es básicamente el tutroial de Guy In a Cube (https://www.youtube.com/watch?v=3_DOF_qjguA), dejo los resultados:

Esto es usando una muestra de datos mediante:
```python
import seaborn as sns
tips = sns.load_dataset("tips")
```
![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/d5a90208-3617-40dd-b836-d10027e11018)

Gráfico de anillos de power bi 

![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/becb4993-eb28-410f-a722-6916932581d9)

Gráfico externo a power bi (swarm, de seaborn):

![image](https://github.com/AaronGS03/Carrera_Python/assets/155577910/3ad56d23-da28-4452-84af-eb5dfe4c9950)


## Día 12 (24/04/2024): 

### Sesión 1 (08:40)

Taller:  Consumo de servicios Restful con Python requests

Taller: Trabajando la concurrencia en Python

Este último taller resultó bastante más complicado de seguir que el resto de lecciones... Quizá porque esté explicando lo que hace sobre dos ejemplos en proyectos ya hechos, con conceptos y haciendo uso de técnicas muy avanzadas... Además lo hace para casos en los que se tienen que realizar operaciones o programas muy repetitivas, llamadas a datos de una api o múltiples cálculos con datos seguidos, para lo que usa ThreadPoolExecutor y ProcessPoolExecutor. Durante mi tiempo en prácticas me encontré con la situación en la que ejecutaba un programa (la captura de tráfico) y quería que esta funcionase al mismo tiempo que el resto del programa, para no tener que esperar para que acabase (5 min) para luego continuar... Para esto, utilicé el modulo subprocess, con el que usando subprocess.run o subprocess.popen puedes ejecutar el script de python que quieras y usando .wait detener la ejecución del resto del script mientras no haya acabado el subproceso o no ponerlo y eso hará que se siga ejecutando en segundo plano. También hice esa prueba de hilos usando el módulo Threading, y parecía funcionar adecuadamente, lo cual me choca con algunas cosas que dice en el taller y me extraña que lo haga usando estos comandos en concreto... Pero veo la utilidad de lo que hizo, en concreto, para este tipo de llamadas repetitivas y cálculos masivos entiendo como podría usar el (Thread/Process)PoolExecutor, por otra parte, está más guiado hacia el intercambio de datos entre funciones y programas, lo cual con subprocess resulta más complicado o limitado. (For the record, le pregunté a mi jefe con respecto al multihilo si lo estaba haciendo bien usando subprocess.run() porque queríamos usar multihilo y pensé que no lo estaba usando o que igual esa forma no servía, y me dijo que sí; que valía sin problema, que era otra forma de hacer multihilo) 

Edit (29/04/2024 11:50):
Tras intentar hacer el ejecutable para la aplicación en las prácticas me encontré con un problema a la hora de las dependencias con los archivos que ejecuto en segundo plano con subprocess al crear el .exe. Por lo tanto decidí cambiar el approach a la forma en la que estaba estructurando el código y usé threads. Revisé la explicación del taller de concurrencia y ahora ya lo comprendo mejor; Thread funciona igual a bajo nivel, pero THreadPoolExecutor es una herramienta para facilitar el proceso, que basicamente se encarga de hacer los joins, waits y asignación de hilos necesasrios de forma automática; entonces yo solo le digo la cantidad de workers (hilos) o no para que haga cpu_count+4 procesos simultaneos y queda todo muy sencillo y compacto:
´´´python
with ThreadPoolExecutor(max_workers=3) as executor:
        print("Comenzando captura de tráfico en segundo plano...")
        executor.submit(trafficScapy.start)
        time.sleep(1)

        if(is_admin):
            print("Comenzando recolección de datos de controles de acceso direccional (DACL) en segundo plano...\nEste proceso tardará bastante.")
            executor.submit(listasCAD.start)
            time.sleep(2)
        
        print("Comenzando lectura de información del sistema")
        executor.submit(sysinfo.sysInfo.start)

        print("Recogiendo actualizaciones de SO y parches")
        executor.submit(sysinfo.sysinfoOSupd.start)
´´´

### Final sesión 1 (11:40)
